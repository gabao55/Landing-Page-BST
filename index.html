<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <title>Landing Page</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
            href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&family=Open+Sans:ital,wght@0,400;0,700;1,400&display=swap"
            rel="stylesheet">
    <link rel="stylesheet" href="assets/CSS/elements.css">
    <link rel="stylesheet" href="assets/CSS/classes.css">
    <link rel="stylesheet" href="assets/CSS/variables.css">
    <link rel="stylesheet" href="assets/CSS/menu.css">
    <link rel="stylesheet" href="assets/CSS/style.css">
</head>
<body>
<input id="close-menu" class="close-menu" type="checkbox"  aria-label="Close menu" role="button">
<label class="close-menu-label" for="close-menu" title="close menu"></label>
<aside class="menu white-bg">
    <div class="main-content menu-content">
        <h1 onclick="getElementById('close-menu').checked = false;">
            <a href="#intro">Gabriel Salateo Rosin</a>
        </h1>
        <nav>
            <ul onclick="getElementById('close-menu').checked = false;">
                <li><a href="#bst">Binary Search Tree</a></li>
                <li><a href="#methods">Methods</a></li>
                <li><a href="#code">Code</a></li>
                <li><a href="#other">Other</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </nav>
    </div>
</aside>
<section class="intro main-bg section" id="intro">
    <div class="main-content intro-content">
        <div class="intro-text-content">
            <h2>Intro</h2>
            <p>This page was developed as a front-end project by Gabriel Salateo Rosin. It is a first contact
                project with HTML, CSS and Javascript and it comes to explaining a little about a very used data
                structure
                called Binary Search Tree (BST), showing some methods involved by the structure, giving examples and
                showing some code developed in C language for it by the site's developer.
                <br>
                In case you get interested by checking other data structures' code or by any of other Gabriel's
                projects,
                you can access his GitHub by clicking the photo!</p>
        </div>
        <a href="https://github.com/gabao55" target="_blank">
            <div class="intro-img">
                <img src="assets/img/foto_linkedin.jpg" alt="GitHub logo that directs to my GitHub page">
            </div>
        </a>
    </div>
</section>
<section class="bst white-bg section" id="bst">
    <div class="main-content bst-content">
        <div class="bst-text-content">
            <h2>Binary Search Tree</h2>
            <p>In computer science, a binary search tree (BST), also called an ordered or sorted binary tree, is a
                rooted binary
                tree whose internal nodes each store a key greater than all the keys in the node's left subtree and less
                than
                those in its right subtree.
                <br>
                A binary tree is a type of data structure for storing data such as numbers in an
                organized way. Binary search trees allow binary search for fast lookup, addition and removal of data
                items, and
                can be used to implement dynamic sets and lookup tables. The order of nodes in a BST means that each
                comparison
                skips about half of the remaining tree, so the whole lookup takes time proportional to the binary
                logarithm of
                the number of items stored in the tree.
                <br>
                This is much better than the linear time required to find items by key
                in an (unsorted) array, but slower than the corresponding operations on hash tables. Several variants of
                the
                binary search tree have been studied.</p>
        </div>
        <div class="bst-img">
            <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/1200px-Binary_search_tree.svg.png" alt="Example of a Binary Search Tree">
        </div>
    </div>
</section>
<section class="methods main-bg section" id="methods">
    <div class="main-content methods-content">
        <h2>Methods of a BST</h2>
        <p>Basically there are three methods, add node, search node and remove node. You can find more about the methods
            in the following video:</p>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/wcIRPqTR3Kc" title="YouTube video player"
                frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>
        <h2>Methods' costs</h2>
        <div class="methods-grid">
            <p>As mentioned in the introduction, a great advantage of binary search trees is the fact they are very
                compact and easy to find data. You can check on the table bellow the cost of each method:</p>
            <br>
            <div class="grid-content">
                <article>
                    <h3>Insertion</h3>
                    <p>The insertion cost is log (n) because of lajnfgaljsfnaslf</p>
                </article>
                <article>
                    <h3>Search</h3>
                    <p>The insertion cost is log (n) because of lajnfgaljsfnaslf</p>
                </article>
                <article>
                    <h3>Removal</h3>
                    <p>The insertion cost is log (n) because of lajnfgaljsfnaslf</p>
                </article>
            </div>
        </div>
    </div>
</section>
<section class="code white-bg section" id="code">
    <div class="main-content">
        <h2>Code in C language</h2>
        <div class="program-name">
            <h3>bst.h</h3>
            <h3>bst.c</h3>
            <h3>main.c</h3>
        </div>
        <div class="program-code">
            <h3 class="program-name-mobile">bst.h</h3>
            <pre>
#include &gtstdio.h&gt
#include &gtstdlib.h&gt

#ifndef INC_11_BST_BST_H
#define INC_11_BST_BST_H

typedef struct node {
    int key;
    struct node *parent; // ascendent in the tree
    struct node *left; // left descendent in the tree
    struct node *right; // right descendente in the tree
} node;

typedef struct tree {
    node *root;
} tree;

/*
 * Frees all the tree's nodes.
 */
void free_nodes(node* p);

/*
 * Frees all the tree's nodes and the tree itself.
 */
void bst_free(tree* T);

/*
 * If the pointer is equal to NULL it allocates a tree, otherwise it frees the current
 * tree and nodes that belong to it and allocates a new tree with no nodes.
 * Returns a pointer to the tree allocated. In case of fail returns NULL.
 */
tree *create(tree *T);

/*
 * Searches for a key in the tree nodes.
 * In case it founds a node containing the key, it returns a pointer to this node,
 * otherwise it returns NULL.
 */
node *search(node *p, int number);

/*
 * Inserts a key into the BST. Returns 1 on success.
 * In case of memory insuficiency, returns 0.
 * In case the key already exists in the tree, it doesn't insert another key and returns 1.
 */
int insert(tree *T, int data);

/*
 * Prints the keys in the order they are visited by a pre-order deep path.
 */
void pre_order_print(node *n);

/*
 * Prints the keys in the order they are visited by a pre-order deep path.
 * In case there are no keys, it prints "arvore vazia".
 */
void pre_order(tree *T);

/*
 * Prints the keys in the order they are visited by a in-order deep path.
 */
void in_order_print(node *n);

/*
 * Prints the keys in the order they are visited by a in-order deep path.
 * In case there are no keys, it prints "arvore vazia".
 */
void in_order(tree *T);

/*
 * Prints the keys in the order they are visited by a post-order deep path.
 */
void post_order_print(node *n);

/*
 * Prints the keys in the order they are visited by a post-order deep path.
 * In case there are no keys, it prints "arvore vazia".
 */
void post_order(tree *T);

/*
 * Returns the node that contains the minimum key of a tree.
 * In case the tree is empty it returns 0.
 */
node *minimum(node *n);

/*
 * Returns the successor of a key in the BST.
 * In case there is no successor or this key in the BST it returns 0.
 */
node *successor(tree *T, int key);

/*
 * Returns the maximum key of a tree.
 * In case the tree is empty it returns 0.
 */
node *maximum(node *n);

/*
 * Returns the predecessor of a key in the BST.
 * In case there is no predecessor or this key in the BST it returns 0.
 */
node *predecessor(tree *T, int key);

/*
 * Removes a node from the BST and places its successor in that position instead.
 * In case there is no node with the referred key in the BST, keeps running the program.
 */
void delete(tree *T, int key);

#endif //INC_11_BST_BST_H
            </pre>
            <h3 class="program-name-mobile">bst.c</h3>
            <pre>
#include &gtstdio.h&gt
#include &gtstdlib.h&gt
#include "bst.h"

/*
 * Frees all the tree's nodes
 */
void free_nodes(node* p) {

    if (p == NULL)
        return;

    free_nodes(p->left);
    free_nodes(p->right);
    free(p);
}

/*
 * Frees all the tree's nodes and the tree itself.
 */
void bst_free(tree* T) {
    free_nodes(T->root);
    free(T);
}

/*
 * If the pointer is equal to NULL it allocates a tree, otherwise it frees the current
 * tree and nodes that belong to it and allocates a new tree with no nodes.
 * Returns a pointer to the tree allocated. In case of memory allocation failure returns NULL.
 */
tree *create(tree *T) {
    if (T != NULL) {
        bst_free(T);
    }

    T = (tree *) calloc(1, sizeof(tree));
    if (T == NULL)
        return NULL;

    T->root = NULL;

    return T;
}

/*
 * Searches for a key in the tree nodes.
 * In case it founds a node containing the key, it returns a pointer to this node,
 * otherwise it returns NULL.
 */
node *search(node *p, int number) {

    if (p == NULL)
        return NULL;

    if (p->key == number)
        return p;

    if (p->key < number)
        return search(p->right, number);
    else
        return search(p->left, number);
}

/*
 * Inserts a key into the BST. Returns 1 on success.
 * In case of memory insuficiency, returns 0.
 * In case the key already exists in the tree, it doesn't insert another key and returns 1.
 */
int insert(tree *T, int data) {
    node* n = calloc(1,sizeof(node));
    if (!n) {
        return 0;
    }

    n->key = data;

    if (T->root == NULL) {
        n->parent = NULL;
        T->root = n;
        return 1;
    }

    if (search(T->root, data) != NULL)
        return 1;

    node* p = T->root;
    node* pp = NULL;

    while (p != NULL) {
        if (p->key == data)
            return 1;
        pp = p;
        if (p->key > data)
            p = p->left;
        else
            p = p->right;
    }


    if (pp->key > data)
        pp->left = n;
    else
        pp->right = n;

    n->parent = pp;

    return 1;
}

/*
 * Prints the keys in the order they are visited by a pre-order deep path.
 */
void pre_order_print(node *n) {
    if (n != NULL) {
        printf("%d ", n->key);
        pre_order_print(n->left);
        pre_order_print(n->right);
    }
}

/*
 * Prints the keys in the order they are visited by a pre-order deep path.
 * In case there are no keys, it prints "arvore vazia".
 */
void pre_order(tree *T) {
    if (T->root == NULL) {
        printf("arvore vazia\n");
        return ;
    }

    printf("pre-ordem: ");
    pre_order_print(T->root);
    printf("\n");
}

/*
 * Prints the keys in the order they are visited by a in-order deep path.
 */
void in_order_print(node *n) {
    if (n != NULL) {
        in_order_print(n->left);
        printf("%d ", n->key);
        in_order_print(n->right);
    }
}

/*
 * Prints the keys in the order they are visited by a in-order deep path.
 * In case there are no keys, it prints "arvore vazia".
 */
void in_order(tree *T) {
    if (T->root == NULL) {
        printf("arvore vazia\n");
        return ;
    }

    printf("em-ordem: ");
    in_order_print(T->root);
    printf("\n");
}

/*
 * Prints the keys in the order they are visited by a post-order deep path.
 */
void post_order_print(node *n) {
    if (n != NULL) {
        post_order_print(n->left);
        post_order_print(n->right);
        printf("%d ", n->key);
    }
}

/*
 * Prints the keys in the order they are visited by a post-order deep path.
 * In case there are no keys, it prints "arvore vazia".
 */
void post_order(tree *T) {
    if (T->root == NULL) {
        printf("arvore vazia\n");
        return ;
    }

    printf("pos-ordem: ");
    post_order_print(T->root);
    printf("\n");
}

/*
 * Returns the minimum key of a tree.
 * In case the tree is empty it returns 0.
 */
node *minimum(node *n) {
    if (n == NULL) {
        return NULL;
    }

    while (n->left != NULL)
        n = n->left;

    return n;
}

/*
 * Returns the successor of a key in the BST.
 * In case there is no successor or this key in the BST it returns 0.
 */
node *successor(tree *T, int key) {
    if (T->root == NULL)
        return NULL;

    node *p;
    node *n;
    n = search(T->root, key);
    if (n == NULL)
        return NULL;
    if (n->right != NULL)
        return minimum(n->right);
    p = n->parent;
    while (p != NULL && n == p->right) {
        n = p;
        p = p->parent;
    }

    if (!p)
        return NULL;

    return p;
}

/*
 * Returns the maximum key of a tree.
 * In case the tree is empty it returns 0.
 */
node *maximum(node *n) {
    if (n == NULL) {
        return 0;
    }

    while (n->right)
        n = n->right;

    return n;
}

/*
 * Returns the predecessor of a key in the BST.
 * In case there is no predecessor or this key in the BST it returns 0.
 */
node *predecessor(tree *T, int key) {
    if (!T->root)
        return 0;

    node *p;
    node *n;
    n = search(T->root, key);
    if (!n)
        return 0;
    if (n->left)
        return maximum(n->left);
    p = n->parent;
    while (p != NULL && n == p->left) {
        n = p;
        p = p->parent;
    }

    if (!p)
        return 0;

    return p;
}

/*
 * Removes a node from the BST and places its successor in that position instead.
 * In case there is no node with the referred key in the BST, keeps running the program.
 */
void delete(tree *T, int key) {
    node *n;
    n = search(T->root, key);

    if (!n)
        return ;

    if (!n->right && !n->left) {
        if (n == T->root) {
            T->root = NULL;
            free(n);
            return ;
        }
        if (n == n->parent->left)
            n->parent->left = NULL;
        if (n == n->parent->right)
            n->parent->right = NULL;
        free(n);
        return ;
    }

    if (n->right && !n->left) {
        if (n == T->root) {
            T->root = n->right;
            n->right->parent = NULL;
            free(n);
            return ;
        }
        if (n == n->parent->right) {
            n->parent->right = n->right;
            n->right->parent = n->parent;
            free(n);
            return ;
        }
        if (n == n->parent->left) {
            n->parent->left = n->right;
            n->right->parent = n->parent;
            free(n);
            return ;
        }
    }

    if (n->left && !n->right) {
        if (n == T->root) {
            T->root = n->left;
            n->left->parent = NULL;
            free(n);
            return ;
        }
        if (n == n->parent->right) {
            n->parent->right = n->left;
            n->left->parent = n->parent;
            free(n);
            return ;
        }
        if (n == n->parent->left) {
            n->parent->left = n->left;
            n->left->parent = n->parent;
            free(n);
            return ;
        }
    }

    if (n->right && n->left) {
        node *y = successor(T, key);
        n->key = y->key;
        if (y == n->right) {
            n->right = y->right;
            if (y->right)
                y->right->parent = n;
            free(y);
            return ;
        }
        if (!y->right) {
            y->parent->left = NULL;
        }
        else {
            y->parent->left = y->right;
            y->right->parent = y->parent;
        }
        free(y);
        return ;
    }
}
            </pre>
            <h3 class="program-name-mobile">main.c</h3>
            <pre>
#include &gtstdlib.h&gt
#include &gtstdio.h&gt
#include &gterrno.h&gt
#include &gtstring.h&gt
#include "bst.h"
#define MAX 50

int main() {
    char cmd[MAX];
    int keep_running = 1;
    int number;
    tree *T = NULL;
    node *n;

    while (keep_running) {
        scanf("%s%*c", cmd);
        if (strcmp(cmd, "inserir") == 0 || strcmp(cmd, "remover") == 0 || strcmp(cmd, "buscar") == 0 ||
            strcmp(cmd, "sucessor") == 0 || strcmp(cmd, "predecessor") == 0)
            scanf(" %d", &number);

        if (strcmp(cmd, "criar") == 0) {
            T = create(T);
            if (!T)
                exit(errno);
        }

        if (strcmp(cmd, "buscar") == 0) {
            n = search(T->root, number);
            if (!n)
                printf("%d nao esta na arvore\n", number);
            else
                printf("%d esta na arvore\n", number);
        }

        if (strcmp(cmd, "inserir") == 0) {
            keep_running = insert(T, number);
            if (!keep_running) {
                printf("memoria insuficiente");
                keep_running = 1;
            }
        }

        if (strcmp(cmd, "pre-ordem") == 0)
            pre_order(T);

        if (strcmp(cmd, "em-ordem") == 0)
            in_order(T);

        if (strcmp(cmd, "pos-ordem") == 0)
            post_order(T);

        if (strcmp(cmd, "sucessor") == 0) {
            n = successor(T, number);
            if (!n)
                printf("nao ha sucessor de %d\n", number);
            else
                printf("sucessor de %d: %d\n", number, n->key);
        }

        if (strcmp(cmd, "predecessor") == 0) {
            n = predecessor(T, number);
            if (!n)
                printf("nao ha predecessor de %d\n", number);
            else
                printf("predecessor de %d: %d\n", number, n->key);
        }

        if (strcmp(cmd, "remover") == 0)
            delete(T, number);

        if (strcmp(cmd, "terminar") == 0) {
            bst_free(T);
            keep_running = 0;
        }
    }

    return 0;
}
            </pre>
        </div>
    </div>
</section>
<section class="other main-bg section" id="other">
    <div class="main-content">
        <h2>Other data structures</h2>
        <div class="methods-grid">
            <div class="grid-content">
                <a href="https://www.geeksforgeeks.org/array-data-structure/">
                    <div class="grid-div">
                        <h3>Arrays</h3>
                        <img src="https://2.bp.blogspot.com/-FQAQTLxRYaE/UFJd3dXglAI/AAAAAAAAAvo/mO2QtNSWTMs/s1600/Curso+Java+Progressivo+-+Arrays.jpg"
                             alt="Array illustration image" target="_blank"
                        class="grid-image">
                    </div>
                </a>
                <a href="https://www.geeksforgeeks.org/stack-data-structure/">
                    <div class="grid-div">
                        <h3>Stacks</h3>
                        <img src="https://www.tutorialspoint.com/data_structures_algorithms/images/stack_representation.jpg"
                             alt="Stack illustration image" target="_blank"
                        class="grid-image">
                    </div>
                </a>
                <a href="https://www.geeksforgeeks.org/queue-data-structure/">
                    <div class="grid-div">
                        <h3>Queues</h3>
                        <img src="https://www.tutorialandexample.com/wp-content/uploads/2020/05/Queue-in-DS-1.jpg"
                             alt="Queue illustration image" target="_blank"
                        class="grid-image">
                    </div>
                </a>
                <a href="https://www.geeksforgeeks.org/data-structures/linked-list/">
                    <div class="grid-div">
                        <h3>Linked Lists</h3>
                        <img src="https://i.stack.imgur.com/jIGTL.png"
                             alt="Linked list illustration image" target="_blank"
                        class="grid-image">
                    </div>
                </a>
                <a href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/">
                    <div class="grid-div">
                        <h3>Graphs</h3>
                        <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTJQNGGnlL5AF0pWxxwtw2K8EAFhg3LB-eUcw&usqp=CAU"
                             alt="Graphs illustration image" target="_blank"
                        class="grid-image">
                    </div>
                </a>
                <a href="https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/">
                    <div class="grid-div">
                        <h3>Hash Tables</h3>
                        <img src="https://linuxhint.com/wp-content/uploads/2020/07/1-66.png"
                             alt="Hash table illustration image" target="_blank"
                        class="grid-image">
                    </div>
                </a>
            </div>
        </div>
    </div>
</section>
<section class="intro white-bg section" id="contact">
    <div class="main-content intro-content">
            <h2>Contact us</h2>
        <div>
        </div>
        <div class="contact-form">
            <fieldset class="form-grid">
                <div class="form-group">
                    <label for="first-name">First name</label>
                    <input type="text" name="first-name" id="first-name"
                    placeholder="Your name">
                </div>
                <div class="form-group">
                    <label for="first-name">Last name</label>
                    <input type="text" name="last-name" id="last-name"
                    placeholder="Your last name">
                </div>
                <div class="form-group">
                    <label for="email">E-mail</label>
                    <input type="text" name="email" id="email"
                    placeholder="Your e-mail">
                </div>
                <div class="form-group full-width">
                    <label for="message">Message</label>
                    <textarea name="message" id="message" cols="30" rows="10"
                    placeholder="Your message"></textarea>
                </div>
                <div class="form-group full-width">
                    <button type="submit">Send message</button>
                </div>
            </fieldset>
        </div>
    </div>
</section>
<footer id="footer" class="footer main-bg">
    <p>Done with <span class="heart">♥</span> by <a href="https://github.com/gabao55" target="_blank">Gabriel Salateo Rosin</a></p>
</footer>
<a class="back-to-top" href="#intro">➤</a>
</body>
</html>
